"""
Contains all common dataclasses, enums & schemas
"""


import importlib

from enum import Enum, EnumMeta
from collections.abc import Iterable, Mapping, Set
from typing import Any


class _ExtendedEnumMeta(EnumMeta):
    def __contains__(self, other: Any) -> bool:
        """ # Summary

        Enables support for open-ended type comparisons in derivative classes
        """
        if isinstance(other, str):
            return other.upper() in self.fields()
        elif isinstance(other, int):
            return other in self.values()
        elif issubclass(other.__class__, self):
            return self(other)
        return False


class ExtendedEnum(Enum, metaclass=_ExtendedEnumMeta):
    """# Summary

    Base class providing extended (common utility functions) feature set to Enum
    """

    @classmethod
    def fields(cls) -> Iterable:
        """# Summary

        Return field values via iterator
        """
        return [c.name.upper() for c in cls]

    @classmethod
    def values(cls) -> Iterable:
        """# Summary

        Returns the values via iterator

        """
        return [c.value for c in cls]

    @classmethod
    def get_name_from_value(cls, value: int) -> Enum:
        """ # Summary
        Finds the name of an enum member from its integer value
        (reverse of get_value_from_name)

       ## Args:
            value: The integer value to look up

       ## Returns:
            The field corresponding to the matching enum member
        """
        for member in cls:
            if member.value == value:
                return member
        raise ValueError(f'"{value}" is not a valid value in {cls.__name__}')

    @classmethod
    def get_value_from_name(cls, name: str) -> Enum:
        """ # Summary
        Finds the value of an enum member from its string value / field name
        (reverse of get_name_from_value)

       ## Args:
            value: The string name to look up

       ## Returns:
            The integer value of the matching enum member
        """
        for member in cls:
            if member.name.upper() == name.upper():
                return member
        raise ValueError(f'"{name}" is not a valid field name in {cls.__name__}')


helpers = importlib.import_module('.helpers', package='Allocator.Interpreter')
combined_fast_stable_hash = helpers.combined_fast_stable_hash


class _BitFieldEnumMeta(EnumMeta):
    """# Summary

    Metaclass for creating Enum types where member values are generated by
    left-shifting an initial integer value by the member's order index.
    """

    @classmethod
    def _get_allowed_names(mcs, allowed_spec: Iterable) -> Set:
        """ # Summary

        Format the allowed spec into a set

        ## Args:
            mcs: _description_ Aliases __new__
            allowed_spec: _description_ The whitelisted attribute names to format

        ## Returns:
            _Set_: _description_ The set wrapped version of allowed_spec
        """
        if allowed_spec is None:
            return None
        if isinstance(allowed_spec, Mapping):
            return set(allowed_spec.keys())
        if isinstance(allowed_spec, Iterable):
            return set(allowed_spec)

    @classmethod
    def _process_member_defs(mcs, allowed_names, clsdict, in_first_msb = True, **kwargs):
        """# Summary

        Iterate through keyword arguments provided at class definition, preserving their order (Python 3.7+).
        Store the attributes as part of the enums class dictionary.

        ## Args:
            mcs (_type_): _description_ Aliases __new__
            allowed_names (_type_): _description_ The whitelisted attribute names
            clsdict (_type_): _description_ Aliases __new__ (enum's class dict)
            in_first_msb (bool, optional): _description_ determines if the first bit is the MSB. Defaults to True.
        """
        for k in kwargs:
            k = str.upper(k)
            if k not in allowed_names:
                raise NameError(
                    f'Member name "{k}" is not allowed for class "{mcs.__name__}". '
                    f'Permitted members are: {sorted(list(allowed_names))}.'
                )

        kwargs_items = kwargs.items()
        kwargs_len = len(kwargs_items) - 1
        for i, (member_name, initial_value) in enumerate(kwargs_items):
            if not isinstance(initial_value, int):
                raise TypeError(
                    f'Value for enum member "{member_name}" must be an integer '
                    f'for bitwise shift, got {type(initial_value).__name__}.'
                )

            if member_name in clsdict:
                raise NameError(
                    f'Enum member name "{member_name}" from keyword arguments '
                    f'conflicts with an item ("{clsdict[member_name]}") already defined in the class body.'
                )

            if in_first_msb:
                final_value = initial_value << (kwargs_len - i)
            else:
                final_value = initial_value << i

            clsdict[member_name] = final_value

    def __new__(mcs, name, bases, clsdict, **kwargs):
        """ ## Summary

        Overrides __new__ class from the enum metaclass. Allows for an enum
        inheriting from BitFieldEnumMeta to concretize it's attributes in
        the class definition, instead of at instantiation in the constructor
        (ala __call__.)
        """
        if kwargs is None:
            raise TypeError(f'class {mcs.__name__} must provide accepted fields')

        allowed_spec = clsdict.get('ALLOWED', None)
        allowed_names = mcs._get_allowed_names(allowed_spec)
        mcs._process_member_defs(
            allowed_names,
            clsdict,
            **kwargs
        )
        return super().__new__(mcs, name, bases, clsdict, **kwargs)


    def __call__(cls, *args, **kwargs):
        """ # Summary

        Overrides the __call__ method of the Enum parent class. I.e. the metaclasses
        enum factory. Names the returned class based on a hash of the key attributes.

        ## Returns:
            _Enum_: _description_ An enum class instance
        """
        if not args and kwargs:
            dynamic_members = {}
            allowed_spec = getattr(cls, 'ALLOWED', None)
            allowed_names = cls._get_allowed_names(allowed_spec.value)
            cls._process_member_defs(
                allowed_names,
                dynamic_members,
                **kwargs
            )

            # Enum factory based on hash of attributes (kwargs)
            # Should be good enough to not create conflicting alias within namespace
            member_items_for_hash = [key.encode('utf-8') for key in kwargs]
            hsh = hex(combined_fast_stable_hash(member_items_for_hash))
            dynamic_name = f'{cls.__name__}_{hsh}'

            return Enum(dynamic_name, dynamic_members)

        if args and not kwargs:
            return super(_BitFieldEnumMeta, cls).__call__(*args)
        if not args and not kwargs:
            return super(_BitFieldEnumMeta, cls).__call__()

        raise TypeError(
            f'{cls.__name__}() called with mixed positional arguments and keyword arguments. '
                'Use keyword arguments only for dynamic enum creation, or positional arguments '
                'only for member lookup.'
        )


class BitField(Enum, metaclass=_BitFieldEnumMeta):
    """# Summary

    Base class for Enums where members are defined via keyword arguments
    to the class definition. The value of each member is the
    provided integer value, LEFT-shifted by its order (index).

    ## Example:
        class MyFlags(OrderedShiftedEnum, F1=1, F2=1, F3=1):
            pass

        MyFlags.F1.value will be 1 (1 << 0)

        MyFlags.F2.value will be 2 (1 << 1)

        MyFlags.F3.value will be 4 (1 << 2)
    """
